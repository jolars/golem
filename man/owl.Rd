% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/owl.R
\name{owl}
\alias{owl}
\title{Generalized Linear Models Penalized with the SLOPE (OWL) Norm}
\usage{
owl(
  x,
  y,
  family = c("gaussian", "binomial", "multinomial", "poisson"),
  intercept = TRUE,
  standardize_features = TRUE,
  sigma = NULL,
  lambda = c("gaussian", "bhq"),
  lambda_min_ratio = if (NROW(x) < NCOL(x)) 0.01 else 1e-04,
  n_sigma = 100,
  q = 0.2,
  screening = FALSE,
  tol_dev_change = 1e-05,
  tol_dev_ratio = 0.995,
  max_variables = NROW(x) + intercept,
  max_passes = 1e+06,
  tol_rel_gap = 1e-05,
  tol_infeas = 1e-04,
  diagnostics = FALSE,
  verbosity = 0
)
}
\arguments{
\item{x}{the feature matrix, which can be either a dense
matrix of the standard \emph{matrix} class, or a sparse matrix
inheriting from \link[Matrix:sparseMatrix]{Matrix::sparseMatrix} Data frames will
be converted to matrices internally.}

\item{y}{the response. For Gaussian models this must be numeric; for
binomial models, it can be a factor.}

\item{family}{response type. See \strong{Families} for details.}

\item{intercept}{whether to fit an intercept}

\item{standardize_features}{whether to standardize features (predictors)}

\item{sigma}{scale of lambda sequence}

\item{lambda}{either a character vector indicating the method used
to construct the lambda path or the a vector or matrix}

\item{lambda_min_ratio}{smallest value for \code{lambda} as a fraction of
\code{lambda_max}}

\item{n_sigma}{length of regularization path}

\item{q}{shape of lambda sequence}

\item{screening}{whether the strong rule for SLOPE be used to screen
variables for inclusion}

\item{tol_dev_change}{the regularization path is stopped if the
fractional change in deviance falls below this value. Note that this is
automatically set to 0 if a sigma is manually entered}

\item{tol_dev_ratio}{the regularization path is stopped if the
deviance ratio
\eqn{1 - \mathrm{deviance}/\mathrm{(null-deviance)}}{1 - deviance/(null deviance)}
is above this threshold}

\item{max_variables}{maximum number of nonzero coefficients in model. The path is}

\item{max_passes}{maximum number of passes for optimizer}

\item{tol_rel_gap}{stopping criterion for the duality gap}

\item{tol_infeas}{stopping criterion for the level of infeasibility}

\item{diagnostics}{should diagnostics be saved for the model fit (timings,
primal and dual objectives, and infeasibility)}

\item{verbosity}{level of verbosity for displaying output from the
program. Setting this to 1 displays information on the path level,
while setting it to 2 displays information also from inside the solver.}
}
\value{
An object of class \code{"Owl"} with the following slots:
\item{coefficients}{
a three-dimensional array of the coefficients from the
model fit, including the intercept if it was fit.
There is one row for each coefficient, one column
for each target (dependent variable), and
one slice for each penalty.
}
\item{nonzeros}{
a three-dimensional boolean array indicating whether a
coefficient was zero or not
}
\item{lambda}{
the lambda vector that when multiplied by a value in \code{sigma}
gives the penalty vector at that point along the regularization
path
}
\item{sigma}{the vector of sigma, indicating the scale of the lambda vector}
\item{class_names}{
a character vector giving the names of the classes for binomial and
multinomial families
}
\item{passes}{the number of passes the solver took at each path}
\item{violations}{the number of violations of the screening rule}
\item{active_sets}{
a list where each element indicates the indices of the
coefficients that were active at that point in the regularization path
}
\item{diagnostics}{
a \code{data.frame} of objective values for the primal and dual problems, as
well as a measure of the infeasibility, time, and iteration. Only
available if \code{diagnostics = TRUE} in the call to \code{\link[=owl]{owl()}}.
}
\item{call}{the call used for fitting the model}
}
\description{
SLOPE (Sorted L-One Penalized Estimation) is an extension of the Lasso.
Unlike the latter, however, SLOPE uses a non-increasing
sequence of \eqn{\lambda}---one
for each coefficient. The penalty term looks like
}
\details{
\deqn{
  \sigma \sum_{i=j}^p \lambda_j |\beta|_{(j)}
}{
  \sigma \sum \lambda |\beta|(j)
}

The objective for each model is simply the loss function for
each family plus a penalty term.
}
\section{Families}{


\strong{Gaussian}

The Gaussian model (Ordinary Least Squares) minimizes the following
objective.

\deqn{
  ||y - X\beta||_2^2
}{
  ||y - X\beta||_2^2
}

\strong{Binomial}

The binomial model (logistic regression) has the following objective.

\deqn{
  \sum_{i=1}^n \log\left(1+ \exp\left(- y_i \left(x_i^T\beta + \alpha \right) \right) \right)
}{
  \sum log(1+ exp(- y_i x_i^T \beta))
}

\strong{Poisson}

In poisson regression, we use the following objective.

\deqn{
  -\sum_{i=1}^n \left(y_i\left(x_i^T\beta + \alpha\right) - \exp\left(x_i^T\beta + \alpha\right)\right)
}{
  -\sum (y_i(x_i^T\beta + \alpha) - exp(x_i^T\beta + \alpha))
}

\strong{Multinomial}

In multinomial regression, we use the following objective.

\deqn{
  -\sum_{i=1}^n\left( \sum_{k=1}^m y_{ik}(x_i^T\beta_k + \alpha_k)
                     - \log\sum_{k=1}^m \exp(x_i^T\beta_k + \alpha_k) \right)
}{
  -\sum(y_ik(x_i^T\beta_k + \alpha_k) - log(\sum exp(x_i^T\beta_k + \alpha_k)))
}
}

\examples{

# Gaussian response

fit <- owl(bodyfat$x, bodyfat$y)

# Binomial response

fit <- owl(heart$x, heart$y, family = "binomial")

# Poisson response

fit <- owl(abalone$x, abalone$y, family = "poisson")

# Multinomial response

fit <- owl(wine$x, wine$y, family = "multinomial")

}
\seealso{
\code{\link[=plot.Owl]{plot.Owl()}}, \code{\link[=plotDiagnostics]{plotDiagnostics()}}, \code{\link[=score]{score()}}, \code{\link[=predict.Owl]{predict.Owl()}},
\code{\link[=trainOwl]{trainOwl()}}
}
