% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/golem.R
\name{golem}
\alias{golem}
\title{Regularized Generalized Linear Models}
\usage{
golem(x, y, groups = NULL, family = c("gaussian", "binomial"),
  penalty = c("slope", "group_slope", "lasso"), solver = "fista",
  intercept = TRUE, standardize_features = TRUE,
  orthogonalize = TRUE, sigma = NULL, lambda = NULL, fdr = 0.2,
  n_lambda = 100, lambda_min_ratio = ifelse(NROW(x) < NCOL(x), 0.01,
  1e-04), tol = 1e-06, max_passes = 10000, diagnostics = FALSE, ...)
}
\arguments{
\item{x}{input matrix}

\item{y}{response variable}

\item{groups}{vector of integers to indicate group membership of each
feature (only relevant for Group SLOPE)}

\item{family}{response type, one of \code{'gaussian'}, \code{'binomial'},
\code{'multinomial'}, or \code{'mgaussian'}. See \strong{Supported families} for details.}

\item{penalty}{the regularization penalty to use, either in the
form of the output from one of this package's penalty functions,
the function itself, or a character vector specifying one such function.
Each function has its respective set of parameters, such as the
regularization strength. Please see
\emph{Regularization Penalties} for more information.}

\item{solver}{the solver to use to optimize the loss function (objective).
Just like the \code{penalty} parameter, this argument may be
either a function, the function's output, or a character vector.
Control arguments (such as convergence threshold) are set in the
solver function itself. Please see \strong{Solvers} for more information.}

\item{intercept}{whether to fit an intercept}

\item{standardize_features}{whether to standardize features (predictors)}

\item{orthogonalize}{whether \code{x} should be orthogonalized}

\item{sigma}{noise estimate (only relevant for SLOPE and Group SLOPE)}

\item{lambda}{either a character vector indicating the method used
to construct the lambda path or}

\item{fdr}{target false discovery rate (only relevant for SLOPE and
Group SLOPE)}

\item{n_lambda}{length of regularization path (only relevant for lasso)}

\item{lambda_min_ratio}{smallest value for \code{lambda} as a fraction of
\eqn{\lambda_\text{max}}{\lambda_max}#'}

\item{tol}{tolerance for optimizer}

\item{max_passes}{maximum number of passes for optimizer}

\item{diagnostics}{should diagnostics be saved for the model fit (timings,
primal and dual objectives, and infeasibility)}

\item{...}{currently ignored}
}
\value{
An object of class \code{"Golem"}.
}
\description{
This functions fits a generalized linear model (GLM) using efficient
optimization routines suitable to big data problems.
}
\section{Regularization Penalties}{

There is a multitude of ways to penalize the models created by
\code{\link[golem:golem]{golem::golem()}}, currently they are:
\itemize{
\item SLOPE
\item Group SLOPE
\item LASSO
}

These functions are in fact only parameter packs for the actual
implementations of the penalties and will be passed on to
the respective C++ creator functions, where the magic happens.

Do \emph{not} attempt to create your own penalty functions using this interface.
Such attempts will most likely be caught in assertions before anything bad
happens, but all bets are off if you are able to sneak them through
the various checks.
}

\section{Solvers}{

There is currently a single solver available for \link[golem:golem]{golem::golem}, namely
\itemize{
\item FISTA
}
}

\examples{
X <- with(mtcars, cbind(cyl, wt, disp, hp, drat))
y <- mtcars$mpg

golem_fit <- golem::golem(X, y, family = "gaussian")
}
